'use strict';

const fs = require('fs');
const multer = require('multer');
const db = require(APP_PATH + '/helpers/database.js');
const permissionManager = require(APP_PATH + '/helpers/PermissionManager.js');
const clientManager = require(APP_PATH + '/helpers/ClientManager.js');
const documentManager = require(APP_PATH + '/helpers/DocumentManager.js');

module.exports.UPLOAD_DEST = `${APP_PATH}/uploads/`;

// Upload function generated by Multer.
const upload = multer({
	dest: module.exports.UPLOAD_DEST,
	limits: { fileSize: (config.maxAssetSize || 20) * 1024 * 1024 }, // 20 MB default.
	fileFilter: fileFilter
}).any();

/**
 * Handles file uploading.
 * @param  {obj} req Express request object.
 * @param  {obj} res Express response object.
 * @public
 */
module.exports.assetUploadHandler = function(req, res) {
	upload(req, res, function(err) {
		if (err) {
			console.error(err);
			return res.status(409).json(err.code === 'LIMIT_FILE_SIZE'  ?
				{ error: `Maximum file size exceeded (${(config.maxAssetSize || 20)} MB).` } : err);
		}

		if (!req.files) {
			return res.status(422).json({ error: 'Parameter missing from request.' });
		}

		const source = `${req.user.userId} (${req.remoteAddress})`;

		module.exports.addAssets(req.webstrateId, req.files, source, (err, assetRecords) => {
			if (err) {
				console.error(err);
				return res.status(409).json({ error: String(err) });
			}
			res.json(assetRecords.length === 1 ? assetRecords[0] : assetRecords);
		});
	});
};

/**
 * Get list of assets.
 * @param  {string}   webstrateId WebstrateId.
 * @param  {Function} next        Callback.
 * @return {array}                (async) List of assets.
 * @public
 */
module.exports.getAssets = function(webstrateId, next) {
	return db.assets.find({ webstrateId }, { _id: 0, webstrateId: 0 })
		.toArray(function(err, assets) {
			if (err) return next && next(err);
			assets.forEach(function(asset) {
				asset.identifier = asset.fileName;
				asset.fileName = asset.originalFileName;
				delete asset.originalFileName;
			});
			return next && next(null, assets);
		});
};

module.exports.getCurrentAssets = function(webstrateId, next) {
	return db.assets.find({ webstrateId }, { _id: 0, webstrateId: 0 })
		.toArray(function(err, assets) {
			if (err) return next && next(err);
			assets = filterNewestAssets(assets);
			return next(null, assets);
		});
};

/**
 * Get information on specific asset.
 * @param  {string}   options.webstrateId WebstrateId.
 * @param  {string}   options.assetName   Asset name.
 * @param  {int}      options.version     Version.
 * @param  {Function} next                Callback.
 * @return {obj}                          (async) Asset object.
 * @public
 */
module.exports.getAsset = function({ webstrateId, assetName, version }, next) {
	var query = { webstrateId, originalFileName: assetName, v: { $lte: version } };
	db.assets.find(query).sort({'v': -1}).limit(1).toArray(function(err, assets) {
		next(err, assets[0]);
	});
};

/**
 * Delete asset from database. This is useful if, for some reason, an asset no longer exists in
 * the file system, but still lingers in the database. Also ensures that the file doesn't exist in
 * the database to avoid lingering files in the file system as well.
 * @param  {string} fileName Name of the file in the file system. This is not the original file
 *                           name used when uploading the file, but rather the 'identifier'.
 * @public
 */
module.exports.deleteAssetFromDatabase = function(fileName) {
	if (!fileName || fs.existsSync(`${module.exports.UPLOAD_DEST}${fileName}`)) return;
	db.assets.deleteOne({ fileName: fileName });
};

/**
 * Copy assets from before a certain version of one webstrate to another.
 * When copying a webstrate we want to copy all the assets over as well. The assets are only
 * duplicated in the database, not in the file system.
 * @param  {[type]}   options.fromWebstrateId WebstrateId of source Webstrate copy assets from.
 * @param  {[type]}   options.toWebstrate     WebstrateId of target Webstrate to copy to.
 * @param  {[type]}   options.version         Copy all assets up to this version. When prototyping
 *                                            off version n, we don't want assets from versions
 *                                            newer than n.
 * @param  {Function} next                    Callback.
 * @public
 */
module.exports.copyAssets = function({ fromWebstrateId, toWebstrateId, version }, next) {
	var query = { webstrateId: fromWebstrateId, v: { $lte: version } };
	db.assets.find(query, { _id: 0 }).toArray(function(err, assets) {
		if (err) return next && next(err);
		assets = filterNewestAssets(assets);

		// If there are no assets, we can terminate.
		if (assets.length === 0) return next();

		// When prototyping a new document, we always start from version 0, so we are going to reset
		// all asset versions to version 0 as well. Also, we need to replace the prototype webstrateId
		// (fromWebstrateId) with target webstrateId (toWebstrateId).
		assets.forEach(function(asset) {
			asset.v = 0;
			asset.webstrateId = toWebstrateId;
		});
		db.assets.insertMany(assets, next);
	});
};

/**
 * Restore assets from an older version of a webstrate to a new version.
 * When requesting an asset without a specific version or tag defined, the newest version is
 * always being served. To prevent newer versions from be served with restored webstrates, we
 * therefore copy the assets and bump their versions, so the the old assets now will be newer
 * than the new assets. Yes, that's a good sentence.
 * @param  {string}   options.webstrateId WebstrateId.
 * @param  {int}      options.version     Version to restore from.
 * @param  {string}   options.tag         Tag to deduce version from if no version is provided.
 * @param  {int}      options.newVersion  Version to bump assets to.
 * @param  {Function} next                Callback.
 * @public
 */
module.exports.restoreAssets = function({ webstrateId, version, tag, newVersion }, next) {
	// We need the version, so if it's not defined, we fetch it, and then call ourselves again,
	// this time with the version paramter set.
	if (!version) {
		return documentManager.getVersionFromTag(webstrateId, tag, function(err, version) {
			if (err) return next && next(err);
			module.exports.restoreAssets({ webstrateId, version, tag, newVersion }, next);
		});
	}

	var query = { webstrateId, v: { $lte: version } };
	db.assets.find(query, { _id: 0 }).toArray(function(err, assets) {

		// If there are no assets, we can terminate.
		if (assets.length === 0) return next();

		if (err) return next && next(err);
		assets = filterNewestAssets(assets);
		// Bump the version of all copied assets.
		assets.forEach(function(asset) {
			asset.v = newVersion;
		});
		db.assets.insertMany(assets, next);
	});
};

/**
 * Delete all assets from a webstrate. If the webstrate has been prototyped/copied, the assets may
 * not be deleted from the file system.
 * @param  {string}   webstrateId WebstrateId to delete assets from.
 * @param  {Function} next        [description]
 * @return {[type]}               [description]
 */
module.exports.deleteAssets = function(webstrateId, next) {
	db.assets.find({ webstrateId }, { _id: 0, fileName: 1 }).toArray(function(err, assets) {
		if (err) return next && next(err);
		// Transform array of objects into primitive array.
		assets.forEach(function(asset, index) {
			assets[index] = asset.fileName;
		});

		// Find all files that are being used by other documents.
		db.assets.distinct('fileName', {
			fileName: { $in: assets },
			webstrateId: { $ne: webstrateId }
		}, function(err, assetsBeingUsed) {
			// Don't delete assets being used by other webstrates.
			var assetsToBeDeleted = assets.filter(function(asset) {
				return !assetsBeingUsed.includes(asset);
			});

			var promises = [];
			// Run through the files and delete them.
			assetsToBeDeleted.forEach(function(asset) {
				promises.push(new Promise(function(resolve, reject) {
					fs.unlink(`${module.exports.UPLOAD_DEST}${asset}`, function(err) {
						// We print out errors, but we don't stop execution. If a file fails to delete, we
						// probably still want to get rid of the remaining files.
						if (err) {
							console.error(err);
						}
						resolve();
					});
				}));
			});

			// Once every file has been deleted from the file system, we delete them from the database.
			Promise.all(promises).then(function() {
				db.assets.deleteMany({ webstrateId }, next);
			});
		});
	});
};

/**
 * Filter assets to only keep the newest version of each.
 * When copying or restoring an asset, we only want the assets with the newest version, e.g. if
 * cow.jpg exists both at version 2 and 3, we only want to save the one from version 3, as that's
 * the one that'd be active in the version we're prototyping from.
 * @param  {array} assets List of assets.
 * @return {array}        Filtered list of assets.
 */
function filterNewestAssets(assets) {
	var filteredAssets = {};
	assets.forEach(function(asset) {
		if (!filteredAssets[asset.originalFileName] ||
			filteredAssets[asset.originalFileName].v < asset.v) {
			filteredAssets[asset.originalFileName] = asset;
		}
	});
	return Object.keys(filteredAssets).map(function(key) {
		return filteredAssets[key];
	});
}

/**
 * Add asset uploaded to the database.
 * This is called when a file is uploaded by the AssetManager, and is therefore private. If an
 * asset name already exists with the specific name at the current version, a random string is
 * added to the file name.
 * @param {string}   webstrateId WebstrateId.
 * @param {obj}      asset       Asset information.
 * @param {string}   source      Origin of assets (some client identifier)
 * @param {Function} next        Callback.
 * @public
 */
module.exports.addAsset = function(webstrateId, asset, source, next) {
	return documentManager.sendNoOp(webstrateId, 'assetAdded', source, function() {
		return documentManager.getDocumentVersion(webstrateId, function(err, version) {
			db.assets.insert({
				webstrateId,
				v: version,
				fileName: asset.filename,
				originalFileName: asset.originalname,
				fileSize: asset.size,
				mimeType: asset.mimetype
			}, function(err) {
				if (err) return next && next(err);

				asset = {
					v: version,
					fileName: asset.originalname,
					fileSize: asset.size,
					mimeType: asset.mimetype,
					identifier: asset.filename
				};

				// Inform all clients of the newly added asset.
				clientManager.sendToClients(webstrateId, {
					wa: 'asset',
					d: webstrateId,
					asset: asset
				});

				return next && next(null, asset);
			});
		});
	});
};

/**
 * Add assets uploaded to the database. Just calls module.exports.addAsset a bunch of times.
 * @param {string}   webstrateId WebstrateId.
 * @param {array}    assets      Array of asset objects.
 * @param {string}   source      Origin of assets (some client identifier)
 * @param {Function} next        Callback.
 * @public
 */
module.exports.addAssets = function(webstrateId, assets, source, next) {
	var assetPromises = [];
	assets.forEach(function(asset) {
		assetPromises.push(new Promise(function(accept, reject) {
			module.exports.addAsset(webstrateId, asset, source, function(err, assetRecord) {
				if (err) return reject(err);
				accept(assetRecord);
			});
		}));
	});

	Promise.all(assetPromises).then(function(assetRecords) {
		next(null, assetRecords.length === 1 ? assetRecords[0] : assetRecords);
	}).catch(function(err) {
		next(err);
	});
};

/**
 * Filter Multer file uploads to ensure that the webstrate exists and that the user has the
 * appropriate permissions.
 * @param  {obj}      req  Express Request object.
 * @param  {obj}      file Multer file object.
 * @param  {Function} next Callback.
 * @return {bool}          (async) Whether the file is permitted to be uploaded or not.
 * @private
 */
function fileFilter(req, file, next) {
	return documentManager.getDocument({ webstrateId: req.webstrateId }, function(err, snapshot) {
		if (err) {
			return next(err);
		}

		if (!snapshot.type) {
			return next(new Error('Document doesn\'t exist.'));
		}

		var permissions = permissionManager.getUserPermissionsFromSnapshot(req.user.username,
			req.user.provider, snapshot);

		if (!permissions.includes('w')) {
			return next(new Error('Insufficient permissions.'));
		}

		return next(null, true);
	});
}